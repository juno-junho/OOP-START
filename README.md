# 🚀 OOP START!

2022년의 마지막날 [YOUTHCON'22](https://frost-witch-afb.notion.site/YOUTHCON-22-a18e4511463a416e8befd99993355215) OOP START!
세션과 함께해요 🙌

## 🤔 무엇을 하나요

절차 지향으로 작성된 자바 어플리케이션을 객체 지향으로 리팩터링해보면서 객체 지향의 필요성을 느껴봅니다!

## 🙆‍♂️ 이런 분들께 추천드려요

✔️ 절차 지향적으로 코드를 작성해온 분

✔️ Getter, Setter 없이 코딩하기 힘든 분

✔️ 객체지향을 학습할 분 또는 학습하고 계신 분

## 객체 지향 프로그래밍이란?

![https://i.ytimg.com/vi/dy9yQIx38u8/maxresdefault.jpg](https://i.ytimg.com/vi/dy9yQIx38u8/maxresdefault.jpg)

변경을 캡슐화한 객체들이 메시지를 통해 협력하는 프로그래밍입니다.
객체 지향 프로그래밍을 통해 변경에 유연한 코드를 작성할 수 있고 유지보수성이 좋아져요 👍

## 📚 이런 걸 배워요

✅ 객체 지향 창시자가 말한 객체 지향의 3요소

✅ 객체 지향의 협력, 책임, 역할

✅ 객체 지향에서 말하는 캡슐화와 다형성

## 🎞️ 실습 시나리오

### 🚚 주문 기능

**Part 0** 절차 지향

- 주문에는 구매할 상품과 고객이 필요하다.
- 상품 주문이 들어오면 상품 재고를 1 감소시킨다.
    - 상품의 재고가 1개 이상일때만 주문이 가능하다.
- 상품 가격만큼 고객의 기프트 카드의 보유액을 감소시킨다.
    - 기프트 카드 보유액은 음수가 될 수 없다.

**Part 1** 메시지

- 메시지 개선

**Part 2** 정보 전문가

- 책임 할당

**Part 3** 의도를 드러내는 인터페이스

- 상품 최소 재고 10개로 변경

- 상품 최소 재고 5개로 변경.

**Part 4** 묻지 말고 시켜라

- 상품 판매시 가격이 1000원 이하면 상품 판매가 불가능하도록 조건 추가

**Part 5** 메서드 캡슐화

- 재고 감소 로직을 캡슐화

**Part 6** 객체 캡슐화

- 기프트 카드와 포인트를 캡슐화

**Part 7** 다형성

- 포인트 결제 추가

**Part 8** 상속

- 중복 코드를 제거

## 📝 기술 스택은 아래와 같습니다

- Java 11
- Gradle 7.5.1
- AssertJ 3.23.1
---
객체 지향은 메세지를 통해 객체 간 전송 (책임 부여)
절차 지향은 한 메소드에 다 때려 박는것

알게 되는 점
객체 지향 전반에 대한 지식
변경에 유연한 코드를 작성할 수 있게 된다
좋은 코드, 좋은 설계가 가능해진다.

alan kay 객체 지향 창시자 -> 메세지, 캡슐화(hiding of state process), 동적 바인딩이 oop의 핵심이다.
변경을 캡슐화한 객체들이 메세지를 통해 협력하는 프로그래밍.

1. 메시지 : 객체들이 **협력**하기 위해 사용할 수 있는 유일한 의사소통 수단
- 송신자와 수신자가 있다. 
- 클래스가 송신자, 메서드 안 객체.메서드 -> 객체가 수신자, 메서드가 메시지
- 메시지 이름으로 충분하지 않으면 파라미터로 추가적인 정보를 넘긴다.
- 수신자는 메시지를 처리할 **책임을** 다하기 위해 메시지를 처리할 방법인 메서드를 선택하게 된다.

협력 : 무엇인가를 요청하는 것. 메시지 전송이 유일한 커뮤니케이션 수단
책임 : 협력에서 수행하는 행동
- `product`는 재고를 감소시키는 책임
- `customer`는 기프트 카드 보유액을 상품 가격만큼 감소시키는 책임

수신자를 정하는 방법
- 책임을 누구에게 할당해줘야 하냐 -> 수신자를 어떻게 정하냐
- GRASP 패턴
  - Information Expert 패턴을 여기서는 사용함
    - 책임을 수행하는데 필요한 정보를 가지고 있는 객체에게 책임을 할당함.
    - 높은 응집도, 낮은 결합도, 유지보수 쉬워진다.
    - 결합도란 내가 얼마나 다른 요소를 많이 알고 있느냐 
    - 해당 정보를 가진 쪽으로만 책임을 부여했기 때문에 높은 응집도.
- 응집도 : 변경이 발생할 때 변경이 발생하는 정도
- 결합도 : 다른 모듈에 대해 얼마나 많은 지식을 가졌는지를 나타내는 척도

- 오퍼레이션 명 (메서드 명을 잘 정하는 방법)
  - `isStockUnderOne`, `isStockUnderTen` 보다 `isStockMin`이라는 메서드 이름
  - 메서드는 자세한, 구체적인 내용을 적는 것이 아니라, 의도만 표현하면 된다.
  - 메서드 명 정할때 중요한 점이 사용하는 클라이언트 쪽에서 메서드 명을 정해야지 받는쪽 입장에서 메서드 명을 정하면 안된다.
  - tell, don't ask. 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.
  - 보유하고 있는 정보나 메시지 전송 결과로 얻게 되는 정보만 사용해 의사결정을 내려라.
  - 메시지 : 직접적인 데이터 공유를 멈추고 메시지로 객체의 자율성을 보장하라.
    - 따라서 메시지를 만들 때 협력 책임 역할을 고려하자.

2. 캡슐화 != 데이터 은닉
- 데이터 캡슐화
  - private로 필드 선언 -> 데이터 캡슐화
- 메서드 캡슐화
  - 메서드 관련 접근 제어자 수정
  - 객체 캡슐화-> composition을 통한 Money 객체 만들기 (giftcard, point 합친것)
- 서브타입 캡슐화 -> 다형성

캡슐화란 변경될 수 있는 어떤 것이라도 감추는 것.
**따라서 내부 구현의 변경으로 외부 객체가 영향 받는다면 캡슐화를 위반한 것**
변화와 불안정성이 다른 요소에 나쁜 영향을 미치지 않도록 방지
받는 쪽을 캡슐화 하는 것도 가능하다 -> 객체 캡슐화

컴포지션(합성) : 객체 캡슐화를 통해 외부 영향을 안미친다. 어떤 giftcard, point 인지 간에.

다형성 : 사전적 의미로 여러 모양.
한가지로 여러가지 기능을 수행할 수 있는 것을 말한다.
자바에서 method overloading, Dynamic binding (런타임에 수신자를 결정하는것.)

객체 지향에서 말하는 다형성은 동적 바인딩이다.
동적 바인딩에 집중해야한다.

```java
    public void payBy(Money money) {
        money.minus(price);
    }
```
이렇게 인터페이스나 부모클래스를 매개변수로 받아서 런타임에 결정되도록 하는것.
이 변경이 외부에 영향을 미치지 않도록 함.
동적 바인딩 : 실행될 메서드를 런타임에 결정하는 방식
자바에서는 업케스팅과 오버라이딩으로 구현할 수 있다.
변하는 것이 있으면 타입 분리 -> 각 타입의 책임으로 할당해라.

책임과 역할의 차이
- 역할은 책임이랑 똑같다. 하지만 역할은 대체될 수 있다.
- money는 역할이고 giftcard, point는 minus라는 책임이 있다.
- 역할은 교체될 수 있는 책임의 집합. -> 역할을 사용해 재사용 가능한 협력을 얻을 수 있다.
- 역할을 통해 기존 코드를 수정하지 않고 재사용할 수 있다. 

동적 바인딩
: 변하는 것이 있으면 역할을 만들어 변화에 유연하게 대처하자.


상속
- dry 원칙: 코드안에 중복이 존재해서는 안된다.
- 이미 존재하는 코드와 유사한 코드가 필요하다면 상속으로 코드를 재사용해라.
- composition이나 동적바이딩 보다 중복도 없어지고 좋아보인다.

하지만 상속의 문제점 : 부모클래스 변화 -> 자식클래스에서도 영향을 미침. 강하게 결합
그래서 중복을 제거하기 위해서 상속을 사용하면 안된다.

- 동시 수정 문제
- 불필요한 인터페이스 상속 문제
- 메서드 오버라이드 오작용의 문제

상속은 자식 클래스의 작성자가 부모클래스의 구현에 대한 정확한 이해를 가지고 있어야 한다.
상속 이용해 코드 재사용하기 위해서는 부모 클래스 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다.

그래서 상속 말고 컴포지션을 사용해야 하는 것이다.
**상속 말고 컴포지션을 활용해라.**

상속을 사용하는 첫 번째 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것.
상속은 has-a is-a 중 **is-a 관계일때 사용한다.** (e.g 포유류는 인간이다.)

상속은 코드 재사용이 목적이면 안된다.
상속의 목적은 타입 계층을 구현하기 위함이다.
상속은 클래스 간의 결합도를 높힌다.

추상클래스와 인터페이스의 차이 : 
추상클래스는 결합도가 훨씬 높다.
원래 default 메서드가 없다는 전제 하에 부모 클래스 변화가 자식 클래스 변화에도 영향을 미친다
낮은 결합도 위해서는 인터페이스 사용하는게 맞다.

추상화
: 불필요한 정보를 제거하고 문제 해결에 필요한 핵심만 남기는 작업

- 구체 클래스 의존성 (상속)
- 추상 클래스 의존성 
- 인터페이스 의존성

밑으로 갈수록 추상적인 존재가 된다.
밑으로 내려감으로서 결합도를 낮출 수 있다. 
추상화를 통해 결합도를 낮출 수 있다.

